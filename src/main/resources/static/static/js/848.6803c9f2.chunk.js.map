{"version":3,"file":"static/js/848.6803c9f2.chunk.js","mappings":"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","sources":["../node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js","../node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js","../node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js","../node_modules/@stomp/stompjs/src/byte.ts","../node_modules/@stomp/stompjs/src/frame-impl.ts","../node_modules/@stomp/stompjs/src/parser.ts","../node_modules/@stomp/stompjs/src/types.ts","../node_modules/@stomp/stompjs/src/versions.ts","../node_modules/@stomp/stompjs/src/stomp-handler.ts","../node_modules/@stomp/stompjs/src/augment-websocket.ts","../node_modules/@stomp/stompjs/src/client.ts"],"sourcesContent":["import memoize from '@emotion/memoize';\n\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23\n\nvar isPropValid = /* #__PURE__ */memoize(function (prop) {\n  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111\n  /* o */\n  && prop.charCodeAt(1) === 110\n  /* n */\n  && prop.charCodeAt(2) < 91;\n}\n/* Z+1 */\n);\n\nexport { isPropValid as default };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport isPropValid from '@emotion/is-prop-valid';\nimport { withEmotionCache, ThemeContext } from '@emotion/react';\nimport { getRegisteredStyles, registerStyles, insertStyles } from '@emotion/utils';\nimport { serializeStyles } from '@emotion/serialize';\nimport { useInsertionEffectAlwaysWithSyncFallback } from '@emotion/use-insertion-effect-with-fallbacks';\n\nvar testOmitPropsOnStringTag = isPropValid;\n\nvar testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {\n  return key !== 'theme';\n};\n\nvar getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {\n  return typeof tag === 'string' && // 96 is one less than the char code\n  // for \"a\" so this is checking that\n  // it's a lowercase character\n  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;\n};\nvar composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {\n  var shouldForwardProp;\n\n  if (options) {\n    var optionsShouldForwardProp = options.shouldForwardProp;\n    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {\n      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);\n    } : optionsShouldForwardProp;\n  }\n\n  if (typeof shouldForwardProp !== 'function' && isReal) {\n    shouldForwardProp = tag.__emotion_forwardProp;\n  }\n\n  return shouldForwardProp;\n};\n\nvar ILLEGAL_ESCAPE_SEQUENCE_ERROR = \"You have illegal escape sequence in your template literal, most likely inside content's property value.\\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \\\"content: '\\\\00d7';\\\" should become \\\"content: '\\\\\\\\00d7';\\\".\\nYou can read more about this here:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences\";\n\nvar Insertion = function Insertion(_ref) {\n  var cache = _ref.cache,\n      serialized = _ref.serialized,\n      isStringTag = _ref.isStringTag;\n  registerStyles(cache, serialized, isStringTag);\n  useInsertionEffectAlwaysWithSyncFallback(function () {\n    return insertStyles(cache, serialized, isStringTag);\n  });\n\n  return null;\n};\n\nvar createStyled = function createStyled(tag, options) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (tag === undefined) {\n      throw new Error('You are trying to create a styled element with an undefined component.\\nYou may have forgotten to import it.');\n    }\n  }\n\n  var isReal = tag.__emotion_real === tag;\n  var baseTag = isReal && tag.__emotion_base || tag;\n  var identifierName;\n  var targetClassName;\n\n  if (options !== undefined) {\n    identifierName = options.label;\n    targetClassName = options.target;\n  }\n\n  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);\n  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);\n  var shouldUseAs = !defaultShouldForwardProp('as');\n  return function () {\n    var args = arguments;\n    var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];\n\n    if (identifierName !== undefined) {\n      styles.push(\"label:\" + identifierName + \";\");\n    }\n\n    if (args[0] == null || args[0].raw === undefined) {\n      styles.push.apply(styles, args);\n    } else {\n      if (process.env.NODE_ENV !== 'production' && args[0][0] === undefined) {\n        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n      }\n\n      styles.push(args[0][0]);\n      var len = args.length;\n      var i = 1;\n\n      for (; i < len; i++) {\n        if (process.env.NODE_ENV !== 'production' && args[0][i] === undefined) {\n          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n        }\n\n        styles.push(args[i], args[0][i]);\n      }\n    } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class\n\n\n    var Styled = withEmotionCache(function (props, cache, ref) {\n      var FinalTag = shouldUseAs && props.as || baseTag;\n      var className = '';\n      var classInterpolations = [];\n      var mergedProps = props;\n\n      if (props.theme == null) {\n        mergedProps = {};\n\n        for (var key in props) {\n          mergedProps[key] = props[key];\n        }\n\n        mergedProps.theme = React.useContext(ThemeContext);\n      }\n\n      if (typeof props.className === 'string') {\n        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);\n      } else if (props.className != null) {\n        className = props.className + \" \";\n      }\n\n      var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);\n      className += cache.key + \"-\" + serialized.name;\n\n      if (targetClassName !== undefined) {\n        className += \" \" + targetClassName;\n      }\n\n      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;\n      var newProps = {};\n\n      for (var _key in props) {\n        if (shouldUseAs && _key === 'as') continue;\n\n        if ( // $FlowFixMe\n        finalShouldForwardProp(_key)) {\n          newProps[_key] = props[_key];\n        }\n      }\n\n      newProps.className = className;\n      newProps.ref = ref;\n      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Insertion, {\n        cache: cache,\n        serialized: serialized,\n        isStringTag: typeof FinalTag === 'string'\n      }), /*#__PURE__*/React.createElement(FinalTag, newProps));\n    });\n    Styled.displayName = identifierName !== undefined ? identifierName : \"Styled(\" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + \")\";\n    Styled.defaultProps = tag.defaultProps;\n    Styled.__emotion_real = Styled;\n    Styled.__emotion_base = baseTag;\n    Styled.__emotion_styles = styles;\n    Styled.__emotion_forwardProp = shouldForwardProp;\n    Object.defineProperty(Styled, 'toString', {\n      value: function value() {\n        if (targetClassName === undefined && process.env.NODE_ENV !== 'production') {\n          return 'NO_COMPONENT_SELECTOR';\n        } // $FlowFixMe: coerce undefined to string\n\n\n        return \".\" + targetClassName;\n      }\n    });\n\n    Styled.withComponent = function (nextTag, nextOptions) {\n      return createStyled(nextTag, _extends({}, options, nextOptions, {\n        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)\n      })).apply(void 0, styles);\n    };\n\n    return Styled;\n  };\n};\n\nexport { createStyled as default };\n","import createStyled from '../base/dist/emotion-styled-base.browser.esm.js';\nimport '@babel/runtime/helpers/extends';\nimport 'react';\nimport '@emotion/is-prop-valid';\nimport '@emotion/react';\nimport '@emotion/utils';\nimport '@emotion/serialize';\nimport '@emotion/use-insertion-effect-with-fallbacks';\n\nvar tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG\n'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];\n\nvar newStyled = createStyled.bind();\ntags.forEach(function (tagName) {\n  // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type\n  newStyled[tagName] = newStyled(tagName);\n});\n\nexport { newStyled as default };\n","/**\n * Some byte values, used as per STOMP specifications.\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport const BYTE = {\n  // LINEFEED byte (octet 10)\n  LF: '\\x0A',\n  // NULL byte (octet 0)\n  NULL: '\\x00',\n};\n","import { BYTE } from './byte.js';\nimport { IFrame } from './i-frame.js';\nimport { StompHeaders } from './stomp-headers.js';\nimport { IRawFrameType } from './types.js';\n\n/**\n * Frame class represents a STOMP frame.\n *\n * @internal\n */\nexport class FrameImpl implements IFrame {\n  /**\n   * STOMP Command\n   */\n  public command: string;\n\n  /**\n   * Headers, key value pairs.\n   */\n  public headers: StompHeaders;\n\n  /**\n   * Is this frame binary (based on whether body/binaryBody was passed when creating this frame).\n   */\n  public isBinaryBody: boolean;\n\n  /**\n   * body of the frame\n   */\n  get body(): string {\n    if (!this._body && this.isBinaryBody) {\n      this._body = new TextDecoder().decode(this._binaryBody);\n    }\n    return this._body || '';\n  }\n  private _body: string | undefined;\n\n  /**\n   * body as Uint8Array\n   */\n  get binaryBody(): Uint8Array {\n    if (!this._binaryBody && !this.isBinaryBody) {\n      this._binaryBody = new TextEncoder().encode(this._body);\n    }\n    // At this stage it will definitely have a valid value\n    return this._binaryBody as Uint8Array;\n  }\n  private _binaryBody: Uint8Array | undefined;\n\n  private escapeHeaderValues: boolean;\n  private skipContentLengthHeader: boolean;\n\n  /**\n   * Frame constructor. `command`, `headers` and `body` are available as properties.\n   *\n   * @internal\n   */\n  constructor(params: {\n    command: string;\n    headers?: StompHeaders;\n    body?: string;\n    binaryBody?: Uint8Array;\n    escapeHeaderValues?: boolean;\n    skipContentLengthHeader?: boolean;\n  }) {\n    const {\n      command,\n      headers,\n      body,\n      binaryBody,\n      escapeHeaderValues,\n      skipContentLengthHeader,\n    } = params;\n    this.command = command;\n    this.headers = (Object as any).assign({}, headers || {});\n\n    if (binaryBody) {\n      this._binaryBody = binaryBody;\n      this.isBinaryBody = true;\n    } else {\n      this._body = body || '';\n      this.isBinaryBody = false;\n    }\n    this.escapeHeaderValues = escapeHeaderValues || false;\n    this.skipContentLengthHeader = skipContentLengthHeader || false;\n  }\n\n  /**\n   * deserialize a STOMP Frame from raw data.\n   *\n   * @internal\n   */\n  public static fromRawFrame(\n    rawFrame: IRawFrameType,\n    escapeHeaderValues: boolean\n  ): FrameImpl {\n    const headers: StompHeaders = {};\n    const trim = (str: string): string => str.replace(/^\\s+|\\s+$/g, '');\n\n    // In case of repeated headers, as per standards, first value need to be used\n    for (const header of rawFrame.headers.reverse()) {\n      const idx = header.indexOf(':');\n\n      const key = trim(header[0]);\n      let value = trim(header[1]);\n\n      if (\n        escapeHeaderValues &&\n        rawFrame.command !== 'CONNECT' &&\n        rawFrame.command !== 'CONNECTED'\n      ) {\n        value = FrameImpl.hdrValueUnEscape(value);\n      }\n\n      headers[key] = value;\n    }\n\n    return new FrameImpl({\n      command: rawFrame.command as string,\n      headers,\n      binaryBody: rawFrame.binaryBody,\n      escapeHeaderValues,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  public toString(): string {\n    return this.serializeCmdAndHeaders();\n  }\n\n  /**\n   * serialize this Frame in a format suitable to be passed to WebSocket.\n   * If the body is string the output will be string.\n   * If the body is binary (i.e. of type Unit8Array) it will be serialized to ArrayBuffer.\n   *\n   * @internal\n   */\n  public serialize(): string | ArrayBuffer {\n    const cmdAndHeaders = this.serializeCmdAndHeaders();\n\n    if (this.isBinaryBody) {\n      return FrameImpl.toUnit8Array(\n        cmdAndHeaders,\n        this._binaryBody as Uint8Array\n      ).buffer;\n    } else {\n      return cmdAndHeaders + this._body + BYTE.NULL;\n    }\n  }\n\n  private serializeCmdAndHeaders(): string {\n    const lines = [this.command];\n    if (this.skipContentLengthHeader) {\n      delete this.headers['content-length'];\n    }\n\n    for (const name of Object.keys(this.headers || {})) {\n      const value = this.headers[name];\n      if (\n        this.escapeHeaderValues &&\n        this.command !== 'CONNECT' &&\n        this.command !== 'CONNECTED'\n      ) {\n        lines.push(`${name}:${FrameImpl.hdrValueEscape(`${value}`)}`);\n      } else {\n        lines.push(`${name}:${value}`);\n      }\n    }\n    if (\n      this.isBinaryBody ||\n      (!this.isBodyEmpty() && !this.skipContentLengthHeader)\n    ) {\n      lines.push(`content-length:${this.bodyLength()}`);\n    }\n    return lines.join(BYTE.LF) + BYTE.LF + BYTE.LF;\n  }\n\n  private isBodyEmpty(): boolean {\n    return this.bodyLength() === 0;\n  }\n\n  private bodyLength(): number {\n    const binaryBody = this.binaryBody;\n    return binaryBody ? binaryBody.length : 0;\n  }\n\n  /**\n   * Compute the size of a UTF-8 string by counting its number of bytes\n   * (and not the number of characters composing the string)\n   */\n  private static sizeOfUTF8(s: string): number {\n    return s ? new TextEncoder().encode(s).length : 0;\n  }\n\n  private static toUnit8Array(\n    cmdAndHeaders: string,\n    binaryBody: Uint8Array\n  ): Uint8Array {\n    const uint8CmdAndHeaders = new TextEncoder().encode(cmdAndHeaders);\n    const nullTerminator = new Uint8Array([0]);\n    const uint8Frame = new Uint8Array(\n      uint8CmdAndHeaders.length + binaryBody.length + nullTerminator.length\n    );\n\n    uint8Frame.set(uint8CmdAndHeaders);\n    uint8Frame.set(binaryBody, uint8CmdAndHeaders.length);\n    uint8Frame.set(\n      nullTerminator,\n      uint8CmdAndHeaders.length + binaryBody.length\n    );\n\n    return uint8Frame;\n  }\n  /**\n   * Serialize a STOMP frame as per STOMP standards, suitable to be sent to the STOMP broker.\n   *\n   * @internal\n   */\n  public static marshall(params: {\n    command: string;\n    headers?: StompHeaders;\n    body?: string;\n    binaryBody?: Uint8Array;\n    escapeHeaderValues?: boolean;\n    skipContentLengthHeader?: boolean;\n  }) {\n    const frame = new FrameImpl(params);\n    return frame.serialize();\n  }\n\n  /**\n   *  Escape header values\n   */\n  private static hdrValueEscape(str: string): string {\n    return str\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/:/g, '\\\\c');\n  }\n\n  /**\n   * UnEscape header values\n   */\n  private static hdrValueUnEscape(str: string): string {\n    return str\n      .replace(/\\\\r/g, '\\r')\n      .replace(/\\\\n/g, '\\n')\n      .replace(/\\\\c/g, ':')\n      .replace(/\\\\\\\\/g, '\\\\');\n  }\n}\n","import { IRawFrameType } from './types.js';\n\n/**\n * @internal\n */\nconst NULL = 0;\n/**\n * @internal\n */\nconst LF = 10;\n/**\n * @internal\n */\nconst CR = 13;\n/**\n * @internal\n */\nconst COLON = 58;\n\n/**\n * This is an evented, rec descent parser.\n * A stream of Octets can be passed and whenever it recognizes\n * a complete Frame or an incoming ping it will invoke the registered callbacks.\n *\n * All incoming Octets are fed into _onByte function.\n * Depending on current state the _onByte function keeps changing.\n * Depending on the state it keeps accumulating into _token and _results.\n * State is indicated by current value of _onByte, all states are named as _collect.\n *\n * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\n * imply that all lengths are considered in bytes (instead of string lengths).\n * So, before actual parsing, if the incoming data is String it is converted to Octets.\n * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\n *\n * There is no peek function on the incoming data.\n * When a state change occurs based on an Octet without consuming the Octet,\n * the Octet, after state change, is fed again (_reinjectByte).\n * This became possible as the state change can be determined by inspecting just one Octet.\n *\n * There are two modes to collect the body, if content-length header is there then it by counting Octets\n * otherwise it is determined by NULL terminator.\n *\n * Following the standards, the command and headers are converted to Strings\n * and the body is returned as Octets.\n * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\n *\n * This parser does not use Regular Expressions as that can only operate on Strings.\n *\n * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\n * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\n * is pushed.\n *\n * Typically the higher level function will convert headers to Hash, handle unescaping of header values\n * (which is protocol version specific), and convert body to text.\n *\n * Check the parser.spec.js to understand cases that this parser is supposed to handle.\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class Parser {\n  private readonly _encoder = new TextEncoder();\n  private readonly _decoder = new TextDecoder();\n\n  // @ts-ignore - it always has a value\n  private _results: IRawFrameType;\n\n  private _token: number[] = [];\n  private _headerKey: string | undefined;\n  private _bodyBytesRemaining: number | undefined;\n\n  // @ts-ignore - it always has a value\n  private _onByte: (byte: number) => void;\n\n  public constructor(\n    public onFrame: (rawFrame: IRawFrameType) => void,\n    public onIncomingPing: () => void\n  ) {\n    this._initState();\n  }\n\n  public parseChunk(\n    segment: string | ArrayBuffer,\n    appendMissingNULLonIncoming: boolean = false\n  ) {\n    let chunk: Uint8Array;\n\n    if (typeof segment === 'string') {\n      chunk = this._encoder.encode(segment);\n    } else {\n      chunk = new Uint8Array(segment);\n    }\n\n    // See https://github.com/stomp-js/stompjs/issues/89\n    // Remove when underlying issue is fixed.\n    //\n    // Send a NULL byte, if the last byte of a Text frame was not NULL.F\n    if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\n      const chunkWithNull = new Uint8Array(chunk.length + 1);\n      chunkWithNull.set(chunk, 0);\n      chunkWithNull[chunk.length] = 0;\n      chunk = chunkWithNull;\n    }\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < chunk.length; i++) {\n      const byte = chunk[i];\n      this._onByte(byte);\n    }\n  }\n\n  // The following implements a simple Rec Descent Parser.\n  // The grammar is simple and just one byte tells what should be the next state\n\n  private _collectFrame(byte: number): void {\n    if (byte === NULL) {\n      // Ignore\n      return;\n    }\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      // Incoming Ping\n      this.onIncomingPing();\n      return;\n    }\n\n    this._onByte = this._collectCommand;\n    this._reinjectByte(byte);\n  }\n\n  private _collectCommand(byte: number): void {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._results.command = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaders;\n      return;\n    }\n\n    this._consumeByte(byte);\n  }\n\n  private _collectHeaders(byte: number): void {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._setupCollectBody();\n      return;\n    }\n    this._onByte = this._collectHeaderKey;\n    this._reinjectByte(byte);\n  }\n\n  private _reinjectByte(byte: number) {\n    this._onByte(byte);\n  }\n\n  private _collectHeaderKey(byte: number): void {\n    if (byte === COLON) {\n      this._headerKey = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaderValue;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _collectHeaderValue(byte: number): void {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._results.headers.push([\n        this._headerKey as string,\n        this._consumeTokenAsUTF8(),\n      ]);\n      this._headerKey = undefined;\n      this._onByte = this._collectHeaders;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _setupCollectBody() {\n    const contentLengthHeader = this._results.headers.filter(\n      (header: [string, string]) => {\n        return header[0] === 'content-length';\n      }\n    )[0];\n\n    if (contentLengthHeader) {\n      this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n      this._onByte = this._collectBodyFixedSize;\n    } else {\n      this._onByte = this._collectBodyNullTerminated;\n    }\n  }\n\n  private _collectBodyNullTerminated(byte: number): void {\n    if (byte === NULL) {\n      this._retrievedBody();\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _collectBodyFixedSize(byte: number): void {\n    // It is post decrement, so that we discard the trailing NULL octet\n    if ((this._bodyBytesRemaining as number)-- === 0) {\n      this._retrievedBody();\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _retrievedBody() {\n    this._results.binaryBody = this._consumeTokenAsRaw();\n\n    try {\n      this.onFrame(this._results);\n    } catch (e) {\n      console.log(\n        `Ignoring an exception thrown by a frame handler. Original exception: `,\n        e\n      );\n    }\n\n    this._initState();\n  }\n\n  // Rec Descent Parser helpers\n\n  private _consumeByte(byte: number) {\n    this._token.push(byte);\n  }\n\n  private _consumeTokenAsUTF8() {\n    return this._decoder.decode(this._consumeTokenAsRaw());\n  }\n\n  private _consumeTokenAsRaw() {\n    const rawResult = new Uint8Array(this._token);\n    this._token = [];\n    return rawResult;\n  }\n\n  private _initState() {\n    this._results = {\n      command: undefined,\n      headers: [],\n      binaryBody: undefined,\n    };\n\n    this._token = [];\n    this._headerKey = undefined;\n\n    this._onByte = this._collectFrame;\n  }\n}\n","import { IFrame } from './i-frame.js';\nimport { IMessage } from './i-message.js';\nimport { StompHeaders } from './stomp-headers.js';\nimport { Versions } from './versions.js';\n\n/**\n * This callback will receive a `string` as a parameter.\n *\n * Part of `@stomp/stompjs`.\n */\nexport type debugFnType = (msg: string) => void;\n\n/**\n * This callback will receive a {@link IMessage} as parameter.\n *\n * Part of `@stomp/stompjs`.\n */\nexport type messageCallbackType = (message: IMessage) => void;\n\n/**\n * This callback will receive a {@link IFrame} as parameter.\n *\n * Part of `@stomp/stompjs`.\n */\nexport type frameCallbackType = ((frame: IFrame) => void) | (() => void);\n\n/**\n * This callback will receive a [CloseEvent]{@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n * as parameter.\n *\n * Part of `@stomp/stompjs`.\n */\nexport type closeEventCallbackType<T = any> = (evt: T) => void;\n\n/**\n * This callback will receive an [Event]{@link https://developer.mozilla.org/en-US/docs/Web/API/Event}\n * as parameter.\n *\n * Part of `@stomp/stompjs`.\n */\nexport type wsErrorCallbackType<T = any> = (evt: T) => void;\n\n/**\n * Parameters for [Client#publish]{@link Client#publish}.\n * Aliased as publishParams as well.\n *\n * Part of `@stomp/stompjs`.\n */\nexport interface IPublishParams {\n  /**\n   * destination end point\n   */\n  destination: string;\n  /**\n   * headers (optional)\n   */\n  headers?: StompHeaders;\n  /**\n   * body (optional)\n   */\n  body?: string;\n  /**\n   * binary body (optional)\n   */\n  binaryBody?: Uint8Array;\n  /**\n   * By default, a `content-length` header will be added in the Frame to the broker.\n   * Set it to `true` for the header to be skipped.\n   */\n  skipContentLengthHeader?: boolean;\n}\n\n/**\n * Backward compatibility, switch to {@link IPublishParams}.\n */\nexport type publishParams = IPublishParams;\n\n/**\n * Used in {@link IRawFrameType}\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport type RawHeaderType = [string, string];\n\n/**\n * The parser yield frames in this structure\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport interface IRawFrameType {\n  command: string | undefined;\n  headers: RawHeaderType[];\n  binaryBody: Uint8Array | undefined;\n}\n\n/**\n * @internal\n */\nexport interface IStompSocketMessageEvent {\n  data?: string | ArrayBuffer;\n}\n\n/**\n * Copied from Websocket interface to avoid dom typelib dependency.\n *\n * @internal\n */\nexport interface IStompSocket {\n  url: string;\n  onclose: ((ev?: any) => any) | undefined | null;\n  onerror: ((ev: any) => any) | undefined | null;\n  onmessage: ((ev: IStompSocketMessageEvent) => any) | undefined | null;\n  onopen: ((ev?: any) => any) | undefined | null;\n  terminate?: (() => any) | undefined | null;\n\n  /**\n   * Returns a string that indicates how binary data from the socket is exposed to scripts:\n   * We support only 'arraybuffer'.\n   */\n  binaryType?: string;\n\n  /**\n   * Returns the state of the socket connection. It can have the values of StompSocketState.\n   */\n  readonly readyState: number;\n\n  /**\n   * Closes the connection.\n   */\n  close(): void;\n  /**\n   * Transmits data using the connection. data can be a string or an ArrayBuffer.\n   */\n  send(data: string | ArrayBuffer): void;\n}\n\n/**\n * Possible states for the IStompSocket\n */\nexport enum StompSocketState {\n  CONNECTING,\n  OPEN,\n  CLOSING,\n  CLOSED,\n}\n\n/**\n * Possible activation state\n */\nexport enum ActivationState {\n  ACTIVE,\n  DEACTIVATING,\n  INACTIVE,\n}\n\n/**\n * @internal\n */\nexport interface IStomptHandlerConfig {\n  debug: debugFnType;\n  stompVersions: Versions;\n  connectHeaders: StompHeaders;\n  disconnectHeaders: StompHeaders;\n  heartbeatIncoming: number;\n  heartbeatOutgoing: number;\n  splitLargeFrames: boolean;\n  maxWebSocketChunkSize: number;\n  forceBinaryWSFrames: boolean;\n  logRawCommunication: boolean;\n  appendMissingNULLonIncoming: boolean;\n  discardWebsocketOnCommFailure: boolean;\n  onConnect: frameCallbackType;\n  onDisconnect: frameCallbackType;\n  onStompError: frameCallbackType;\n  onWebSocketClose: closeEventCallbackType;\n  onWebSocketError: wsErrorCallbackType;\n  onUnhandledMessage: messageCallbackType;\n  onUnhandledReceipt: frameCallbackType;\n  onUnhandledFrame: frameCallbackType;\n}\n","/**\n * Supported STOMP versions\n *\n * Part of `@stomp/stompjs`.\n */\nexport class Versions {\n  /**\n   * Indicates protocol version 1.0\n   */\n  public static V1_0 = '1.0';\n  /**\n   * Indicates protocol version 1.1\n   */\n  public static V1_1 = '1.1';\n  /**\n   * Indicates protocol version 1.2\n   */\n  public static V1_2 = '1.2';\n\n  /**\n   * @internal\n   */\n  public static default = new Versions([\n    Versions.V1_2,\n    Versions.V1_1,\n    Versions.V1_0,\n  ]);\n\n  /**\n   * Takes an array of versions, typical elements '1.2', '1.1', or '1.0'\n   *\n   * You will be creating an instance of this class if you want to override\n   * supported versions to be declared during STOMP handshake.\n   */\n  constructor(public versions: string[]) {}\n\n  /**\n   * Used as part of CONNECT STOMP Frame\n   */\n  public supportedVersions() {\n    return this.versions.join(',');\n  }\n\n  /**\n   * Used while creating a WebSocket\n   */\n  public protocolVersions() {\n    return this.versions.map(x => `v${x.replace('.', '')}.stomp`);\n  }\n}\n","import { BYTE } from './byte.js';\nimport { Client } from './client.js';\nimport { FrameImpl } from './frame-impl.js';\nimport { IMessage } from './i-message.js';\nimport { ITransaction } from './i-transaction.js';\nimport { Parser } from './parser.js';\nimport { StompHeaders } from './stomp-headers.js';\nimport { StompSubscription } from './stomp-subscription.js';\nimport {\n  closeEventCallbackType,\n  debugFnType,\n  frameCallbackType,\n  IPublishParams,\n  IStompSocket,\n  IStompSocketMessageEvent,\n  IStomptHandlerConfig,\n  messageCallbackType,\n  StompSocketState,\n  wsErrorCallbackType,\n} from './types.js';\nimport { Versions } from './versions.js';\nimport { augmentWebsocket } from './augment-websocket.js';\n\n/**\n * The STOMP protocol handler\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class StompHandler {\n  public debug: debugFnType;\n\n  public stompVersions: Versions;\n\n  public connectHeaders: StompHeaders;\n\n  public disconnectHeaders: StompHeaders;\n\n  public heartbeatIncoming: number;\n\n  public heartbeatOutgoing: number;\n\n  public onUnhandledMessage: messageCallbackType;\n\n  public onUnhandledReceipt: frameCallbackType;\n\n  public onUnhandledFrame: frameCallbackType;\n\n  public onConnect: frameCallbackType;\n\n  public onDisconnect: frameCallbackType;\n\n  public onStompError: frameCallbackType;\n\n  public onWebSocketClose: closeEventCallbackType;\n\n  public onWebSocketError: wsErrorCallbackType;\n\n  public logRawCommunication: boolean;\n\n  public splitLargeFrames: boolean;\n\n  public maxWebSocketChunkSize: number;\n\n  public forceBinaryWSFrames: boolean;\n\n  public appendMissingNULLonIncoming: boolean;\n\n  public discardWebsocketOnCommFailure: boolean;\n\n  get connectedVersion(): string | undefined {\n    return this._connectedVersion;\n  }\n  private _connectedVersion: string | undefined;\n\n  get connected(): boolean {\n    return this._connected;\n  }\n\n  private _connected: boolean = false;\n\n  private readonly _subscriptions: { [key: string]: messageCallbackType };\n  private readonly _receiptWatchers: { [key: string]: frameCallbackType };\n  private _partialData: string;\n  private _escapeHeaderValues: boolean;\n  private _counter: number;\n  private _pinger: any;\n  private _ponger: any;\n  private _lastServerActivityTS: number;\n\n  constructor(\n    private _client: Client,\n    public _webSocket: IStompSocket,\n    config: IStomptHandlerConfig\n  ) {\n    // used to index subscribers\n    this._counter = 0;\n\n    // subscription callbacks indexed by subscriber's ID\n    this._subscriptions = {};\n\n    // receipt-watchers indexed by receipts-ids\n    this._receiptWatchers = {};\n\n    this._partialData = '';\n\n    this._escapeHeaderValues = false;\n\n    this._lastServerActivityTS = Date.now();\n\n    this.debug = config.debug;\n    this.stompVersions = config.stompVersions;\n    this.connectHeaders = config.connectHeaders;\n    this.disconnectHeaders = config.disconnectHeaders;\n    this.heartbeatIncoming = config.heartbeatIncoming;\n    this.heartbeatOutgoing = config.heartbeatOutgoing;\n    this.splitLargeFrames = config.splitLargeFrames;\n    this.maxWebSocketChunkSize = config.maxWebSocketChunkSize;\n    this.forceBinaryWSFrames = config.forceBinaryWSFrames;\n    this.logRawCommunication = config.logRawCommunication;\n    this.appendMissingNULLonIncoming = config.appendMissingNULLonIncoming;\n    this.discardWebsocketOnCommFailure = config.discardWebsocketOnCommFailure;\n    this.onConnect = config.onConnect;\n    this.onDisconnect = config.onDisconnect;\n    this.onStompError = config.onStompError;\n    this.onWebSocketClose = config.onWebSocketClose;\n    this.onWebSocketError = config.onWebSocketError;\n    this.onUnhandledMessage = config.onUnhandledMessage;\n    this.onUnhandledReceipt = config.onUnhandledReceipt;\n    this.onUnhandledFrame = config.onUnhandledFrame;\n  }\n\n  public start(): void {\n    const parser = new Parser(\n      // On Frame\n      rawFrame => {\n        const frame = FrameImpl.fromRawFrame(\n          rawFrame,\n          this._escapeHeaderValues\n        );\n\n        // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n        if (!this.logRawCommunication) {\n          this.debug(`<<< ${frame}`);\n        }\n\n        const serverFrameHandler =\n          this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n        serverFrameHandler(frame);\n      },\n      // On Incoming Ping\n      () => {\n        this.debug('<<< PONG');\n      }\n    );\n\n    this._webSocket.onmessage = (evt: IStompSocketMessageEvent) => {\n      this.debug('Received data');\n      this._lastServerActivityTS = Date.now();\n\n      if (this.logRawCommunication) {\n        const rawChunkAsString =\n          evt.data instanceof ArrayBuffer\n            ? new TextDecoder().decode(evt.data)\n            : evt.data;\n        this.debug(`<<< ${rawChunkAsString}`);\n      }\n\n      parser.parseChunk(\n        evt.data as string | ArrayBuffer,\n        this.appendMissingNULLonIncoming\n      );\n    };\n\n    this._webSocket.onclose = (closeEvent): void => {\n      this.debug(`Connection closed to ${this._webSocket.url}`);\n      this._cleanUp();\n      this.onWebSocketClose(closeEvent);\n    };\n\n    this._webSocket.onerror = (errorEvent): void => {\n      this.onWebSocketError(errorEvent);\n    };\n\n    this._webSocket.onopen = () => {\n      // Clone before updating\n      const connectHeaders = (Object as any).assign({}, this.connectHeaders);\n\n      this.debug('Web Socket Opened...');\n      connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n      connectHeaders['heart-beat'] = [\n        this.heartbeatOutgoing,\n        this.heartbeatIncoming,\n      ].join(',');\n      this._transmit({ command: 'CONNECT', headers: connectHeaders });\n    };\n  }\n\n  private readonly _serverFrameHandlers: {\n    [key: string]: frameCallbackType;\n  } = {\n    // [CONNECTED Frame](https://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n    CONNECTED: frame => {\n      this.debug(`connected to server ${frame.headers.server}`);\n      this._connected = true;\n      this._connectedVersion = frame.headers.version;\n      // STOMP version 1.2 needs header values to be escaped\n      if (this._connectedVersion === Versions.V1_2) {\n        this._escapeHeaderValues = true;\n      }\n\n      this._setupHeartbeat(frame.headers);\n      this.onConnect(frame);\n    },\n\n    // [MESSAGE Frame](https://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n    MESSAGE: frame => {\n      // the callback is registered when the client calls\n      // `subscribe()`.\n      // If there is no registered subscription for the received message,\n      // the default `onUnhandledMessage` callback is used that the client can set.\n      // This is useful for subscriptions that are automatically created\n      // on the browser side (e.g. [RabbitMQ's temporary\n      // queues](https://www.rabbitmq.com/stomp.html)).\n      const subscription = frame.headers.subscription;\n      const onReceive =\n        this._subscriptions[subscription] || this.onUnhandledMessage;\n\n      // bless the frame to be a Message\n      const message = frame as IMessage;\n\n      const client = this;\n      const messageId =\n        this._connectedVersion === Versions.V1_2\n          ? message.headers.ack\n          : message.headers['message-id'];\n\n      // add `ack()` and `nack()` methods directly to the returned frame\n      // so that a simple call to `message.ack()` can acknowledge the message.\n      message.ack = (headers: StompHeaders = {}): void => {\n        return client.ack(messageId, subscription, headers);\n      };\n      message.nack = (headers: StompHeaders = {}): void => {\n        return client.nack(messageId, subscription, headers);\n      };\n      onReceive(message);\n    },\n\n    // [RECEIPT Frame](https://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n    RECEIPT: frame => {\n      const callback = this._receiptWatchers[frame.headers['receipt-id']];\n      if (callback) {\n        callback(frame);\n        // Server will acknowledge only once, remove the callback\n        delete this._receiptWatchers[frame.headers['receipt-id']];\n      } else {\n        this.onUnhandledReceipt(frame);\n      }\n    },\n\n    // [ERROR Frame](https://stomp.github.com/stomp-specification-1.2.html#ERROR)\n    ERROR: frame => {\n      this.onStompError(frame);\n    },\n  };\n\n  private _setupHeartbeat(headers: StompHeaders): void {\n    if (\n      headers.version !== Versions.V1_1 &&\n      headers.version !== Versions.V1_2\n    ) {\n      return;\n    }\n\n    // It is valid for the server to not send this header\n    // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n    if (!headers['heart-beat']) {\n      return;\n    }\n\n    // heart-beat header received from the server looks like:\n    //\n    //     heart-beat: sx, sy\n    const [serverOutgoing, serverIncoming] = headers['heart-beat']\n      .split(',')\n      .map((v: string) => parseInt(v, 10));\n\n    if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n      const ttl: number = Math.max(this.heartbeatOutgoing, serverIncoming);\n      this.debug(`send PING every ${ttl}ms`);\n      this._pinger = setInterval(() => {\n        if (this._webSocket.readyState === StompSocketState.OPEN) {\n          this._webSocket.send(BYTE.LF);\n          this.debug('>>> PING');\n        }\n      }, ttl);\n    }\n\n    if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n      const ttl: number = Math.max(this.heartbeatIncoming, serverOutgoing);\n      this.debug(`check PONG every ${ttl}ms`);\n      this._ponger = setInterval(() => {\n        const delta = Date.now() - this._lastServerActivityTS;\n        // We wait twice the TTL to be flexible on window's setInterval calls\n        if (delta > ttl * 2) {\n          this.debug(`did not receive server activity for the last ${delta}ms`);\n          this._closeOrDiscardWebsocket();\n        }\n      }, ttl);\n    }\n  }\n\n  private _closeOrDiscardWebsocket() {\n    if (this.discardWebsocketOnCommFailure) {\n      this.debug(\n        'Discarding websocket, the underlying socket may linger for a while'\n      );\n      this.discardWebsocket();\n    } else {\n      this.debug('Issuing close on the websocket');\n      this._closeWebsocket();\n    }\n  }\n\n  public forceDisconnect() {\n    if (this._webSocket) {\n      if (\n        this._webSocket.readyState === StompSocketState.CONNECTING ||\n        this._webSocket.readyState === StompSocketState.OPEN\n      ) {\n        this._closeOrDiscardWebsocket();\n      }\n    }\n  }\n\n  public _closeWebsocket() {\n    this._webSocket.onmessage = () => {}; // ignore messages\n    this._webSocket.close();\n  }\n\n  public discardWebsocket() {\n    if (typeof this._webSocket.terminate !== 'function') {\n      augmentWebsocket(this._webSocket, (msg: string) => this.debug(msg));\n    }\n\n    // @ts-ignore - this method will be there at this stage\n    this._webSocket.terminate();\n  }\n\n  private _transmit(params: {\n    command: string;\n    headers?: StompHeaders;\n    body?: string;\n    binaryBody?: Uint8Array;\n    skipContentLengthHeader?: boolean;\n  }): void {\n    const { command, headers, body, binaryBody, skipContentLengthHeader } =\n      params;\n    const frame = new FrameImpl({\n      command,\n      headers,\n      body,\n      binaryBody,\n      escapeHeaderValues: this._escapeHeaderValues,\n      skipContentLengthHeader,\n    });\n\n    let rawChunk = frame.serialize();\n\n    if (this.logRawCommunication) {\n      this.debug(`>>> ${rawChunk}`);\n    } else {\n      this.debug(`>>> ${frame}`);\n    }\n\n    if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n      rawChunk = new TextEncoder().encode(rawChunk);\n    }\n\n    if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n      this._webSocket.send(rawChunk);\n    } else {\n      let out = rawChunk as string;\n      while (out.length > 0) {\n        const chunk = out.substring(0, this.maxWebSocketChunkSize);\n        out = out.substring(this.maxWebSocketChunkSize);\n        this._webSocket.send(chunk);\n        this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\n      }\n    }\n  }\n\n  public dispose(): void {\n    if (this.connected) {\n      try {\n        // clone before updating\n        const disconnectHeaders = (Object as any).assign(\n          {},\n          this.disconnectHeaders\n        );\n\n        if (!disconnectHeaders.receipt) {\n          disconnectHeaders.receipt = `close-${this._counter++}`;\n        }\n        this.watchForReceipt(disconnectHeaders.receipt, frame => {\n          this._closeWebsocket();\n          this._cleanUp();\n          this.onDisconnect(frame);\n        });\n        this._transmit({ command: 'DISCONNECT', headers: disconnectHeaders });\n      } catch (error) {\n        this.debug(`Ignoring error during disconnect ${error}`);\n      }\n    } else {\n      if (\n        this._webSocket.readyState === StompSocketState.CONNECTING ||\n        this._webSocket.readyState === StompSocketState.OPEN\n      ) {\n        this._closeWebsocket();\n      }\n    }\n  }\n\n  private _cleanUp() {\n    this._connected = false;\n\n    if (this._pinger) {\n      clearInterval(this._pinger);\n      this._pinger = undefined;\n    }\n    if (this._ponger) {\n      clearInterval(this._ponger);\n      this._ponger = undefined;\n    }\n  }\n\n  public publish(params: IPublishParams): void {\n    const { destination, headers, body, binaryBody, skipContentLengthHeader } =\n      params;\n    const hdrs: StompHeaders = (Object as any).assign({ destination }, headers);\n    this._transmit({\n      command: 'SEND',\n      headers: hdrs,\n      body,\n      binaryBody,\n      skipContentLengthHeader,\n    });\n  }\n\n  public watchForReceipt(receiptId: string, callback: frameCallbackType): void {\n    this._receiptWatchers[receiptId] = callback;\n  }\n\n  public subscribe(\n    destination: string,\n    callback: messageCallbackType,\n    headers: StompHeaders = {}\n  ): StompSubscription {\n    headers = (Object as any).assign({}, headers);\n\n    if (!headers.id) {\n      headers.id = `sub-${this._counter++}`;\n    }\n    headers.destination = destination;\n    this._subscriptions[headers.id] = callback;\n    this._transmit({ command: 'SUBSCRIBE', headers });\n    const client = this;\n    return {\n      id: headers.id,\n\n      unsubscribe(hdrs) {\n        return client.unsubscribe(headers.id, hdrs);\n      },\n    };\n  }\n\n  public unsubscribe(id: string, headers: StompHeaders = {}): void {\n    headers = (Object as any).assign({}, headers);\n\n    delete this._subscriptions[id];\n    headers.id = id;\n    this._transmit({ command: 'UNSUBSCRIBE', headers });\n  }\n\n  public begin(transactionId: string): ITransaction {\n    const txId = transactionId || `tx-${this._counter++}`;\n    this._transmit({\n      command: 'BEGIN',\n      headers: {\n        transaction: txId,\n      },\n    });\n    const client = this;\n    return {\n      id: txId,\n      commit(): void {\n        client.commit(txId);\n      },\n      abort(): void {\n        client.abort(txId);\n      },\n    };\n  }\n\n  public commit(transactionId: string): void {\n    this._transmit({\n      command: 'COMMIT',\n      headers: {\n        transaction: transactionId,\n      },\n    });\n  }\n\n  public abort(transactionId: string): void {\n    this._transmit({\n      command: 'ABORT',\n      headers: {\n        transaction: transactionId,\n      },\n    });\n  }\n\n  public ack(\n    messageId: string,\n    subscriptionId: string,\n    headers: StompHeaders = {}\n  ): void {\n    headers = (Object as any).assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n    headers.subscription = subscriptionId;\n    this._transmit({ command: 'ACK', headers });\n  }\n\n  public nack(\n    messageId: string,\n    subscriptionId: string,\n    headers: StompHeaders = {}\n  ): void {\n    headers = (Object as any).assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n    headers.subscription = subscriptionId;\n    return this._transmit({ command: 'NACK', headers });\n  }\n}\n","import { IStompSocket } from './types.js';\n\n/**\n * @internal\n */\nexport function augmentWebsocket(\n  webSocket: IStompSocket,\n  debug: (msg: string) => void\n) {\n  webSocket.terminate = function () {\n    const noOp = () => {};\n\n    // set all callbacks to no op\n    this.onerror = noOp;\n    this.onmessage = noOp;\n    this.onopen = noOp;\n\n    const ts = new Date();\n    const id = Math.random().toString().substring(2, 8); // A simulated id\n\n    const origOnClose = this.onclose;\n\n    // Track delay in actual closure of the socket\n    this.onclose = closeEvent => {\n      const delay = new Date().getTime() - ts.getTime();\n      debug(\n        `Discarded socket (#${id})  closed after ${delay}ms, with code/reason: ${closeEvent.code}/${closeEvent.reason}`\n      );\n    };\n\n    this.close();\n\n    origOnClose?.call(webSocket, {\n      code: 4001,\n      reason: `Quick discarding socket (#${id}) without waiting for the shutdown sequence.`,\n      wasClean: false,\n    });\n  };\n}\n","import { ITransaction } from './i-transaction.js';\nimport { StompConfig } from './stomp-config.js';\nimport { StompHandler } from './stomp-handler.js';\nimport { StompHeaders } from './stomp-headers.js';\nimport { StompSubscription } from './stomp-subscription.js';\nimport {\n  ActivationState,\n  closeEventCallbackType,\n  debugFnType,\n  frameCallbackType,\n  IPublishParams,\n  IStompSocket,\n  messageCallbackType,\n  StompSocketState,\n  wsErrorCallbackType,\n} from './types.js';\nimport { Versions } from './versions.js';\n\n/**\n * @internal\n */\ndeclare const WebSocket: {\n  prototype: IStompSocket;\n  new (url: string, protocols?: string | string[]): IStompSocket;\n};\n\n/**\n * STOMP Client Class.\n *\n * Part of `@stomp/stompjs`.\n */\nexport class Client {\n  /**\n   * The URL for the STOMP broker to connect to.\n   * Typically like `\"ws://broker.329broker.com:15674/ws\"` or `\"wss://broker.329broker.com:15674/ws\"`.\n   *\n   * Only one of this or [Client#webSocketFactory]{@link Client#webSocketFactory} need to be set.\n   * If both are set, [Client#webSocketFactory]{@link Client#webSocketFactory} will be used.\n   *\n   * If your environment does not support WebSockets natively, please refer to\n   * [Polyfills]{@link https://stomp-js.github.io/guide/stompjs/rx-stomp/ng2-stompjs/pollyfils-for-stompjs-v5.html}.\n   */\n  public brokerURL: string | undefined;\n\n  /**\n   * STOMP versions to attempt during STOMP handshake. By default, versions `1.2`, `1.1`, and `1.0` are attempted.\n   *\n   * Example:\n   * ```javascript\n   *        // Try only versions 1.1 and 1.0\n   *        client.stompVersions = new Versions(['1.1', '1.0'])\n   * ```\n   */\n  public stompVersions = Versions.default;\n\n  /**\n   * This function should return a WebSocket or a similar (e.g. SockJS) object.\n   * If your environment does not support WebSockets natively, please refer to\n   * [Polyfills]{@link https://stomp-js.github.io/guide/stompjs/rx-stomp/ng2-stompjs/pollyfils-for-stompjs-v5.html}.\n   * If your STOMP Broker supports WebSockets, prefer setting [Client#brokerURL]{@link Client#brokerURL}.\n   *\n   * If both this and [Client#brokerURL]{@link Client#brokerURL} are set, this will be used.\n   *\n   * Example:\n   * ```javascript\n   *        // use a WebSocket\n   *        client.webSocketFactory= function () {\n   *          return new WebSocket(\"wss://broker.329broker.com:15674/ws\");\n   *        };\n   *\n   *        // Typical usage with SockJS\n   *        client.webSocketFactory= function () {\n   *          return new SockJS(\"http://broker.329broker.com/stomp\");\n   *        };\n   * ```\n   */\n  public webSocketFactory: (() => IStompSocket) | undefined;\n\n  /**\n   * Will retry if Stomp connection is not established in specified milliseconds.\n   * Default 0, which switches off automatic reconnection.\n   */\n  public connectionTimeout: number = 0;\n\n  // As per https://stackoverflow.com/questions/45802988/typescript-use-correct-version-of-settimeout-node-vs-window/56239226#56239226\n  private _connectionWatcher: ReturnType<typeof setTimeout> | undefined; // Timer\n\n  /**\n   *  automatically reconnect with delay in milliseconds, set to 0 to disable.\n   */\n  public reconnectDelay: number = 5000;\n\n  /**\n   * Incoming heartbeat interval in milliseconds. Set to 0 to disable.\n   */\n  public heartbeatIncoming: number = 10000;\n\n  /**\n   * Outgoing heartbeat interval in milliseconds. Set to 0 to disable.\n   */\n  public heartbeatOutgoing: number = 10000;\n\n  /**\n   * This switches on a non-standard behavior while sending WebSocket packets.\n   * It splits larger (text) packets into chunks of [maxWebSocketChunkSize]{@link Client#maxWebSocketChunkSize}.\n   * Only Java Spring brokers seem to support this mode.\n   *\n   * WebSockets, by itself, split large (text) packets,\n   * so it is not needed with a truly compliant STOMP/WebSocket broker.\n   * Setting it for such a broker will cause large messages to fail.\n   *\n   * `false` by default.\n   *\n   * Binary frames are never split.\n   */\n  public splitLargeFrames: boolean = false;\n\n  /**\n   * See [splitLargeFrames]{@link Client#splitLargeFrames}.\n   * This has no effect if [splitLargeFrames]{@link Client#splitLargeFrames} is `false`.\n   */\n  public maxWebSocketChunkSize: number = 8 * 1024;\n\n  /**\n   * Usually the\n   * [type of WebSocket frame]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send#Parameters}\n   * is automatically decided by type of the payload.\n   * Default is `false`, which should work with all compliant brokers.\n   *\n   * Set this flag to force binary frames.\n   */\n  public forceBinaryWSFrames: boolean = false;\n\n  /**\n   * A bug in ReactNative chops a string on occurrence of a NULL.\n   * See issue [https://github.com/stomp-js/stompjs/issues/89]{@link https://github.com/stomp-js/stompjs/issues/89}.\n   * This makes incoming WebSocket messages invalid STOMP packets.\n   * Setting this flag attempts to reverse the damage by appending a NULL.\n   * If the broker splits a large message into multiple WebSocket messages,\n   * this flag will cause data loss and abnormal termination of connection.\n   *\n   * This is not an ideal solution, but a stop gap until the underlying issue is fixed at ReactNative library.\n   */\n  public appendMissingNULLonIncoming: boolean = false;\n\n  /**\n   * Underlying WebSocket instance, READONLY.\n   */\n  get webSocket(): IStompSocket | undefined {\n    return this._stompHandler?._webSocket;\n  }\n\n  /**\n   * Connection headers, important keys - `login`, `passcode`, `host`.\n   * Though STOMP 1.2 standard marks these keys to be present, check your broker documentation for\n   * details specific to your broker.\n   */\n  public connectHeaders: StompHeaders;\n\n  /**\n   * Disconnection headers.\n   */\n  get disconnectHeaders(): StompHeaders {\n    return this._disconnectHeaders;\n  }\n\n  set disconnectHeaders(value: StompHeaders) {\n    this._disconnectHeaders = value;\n    if (this._stompHandler) {\n      this._stompHandler.disconnectHeaders = this._disconnectHeaders;\n    }\n  }\n  private _disconnectHeaders: StompHeaders;\n\n  /**\n   * This function will be called for any unhandled messages.\n   * It is useful for receiving messages sent to RabbitMQ temporary queues.\n   *\n   * It can also get invoked with stray messages while the server is processing\n   * a request to [Client#unsubscribe]{@link Client#unsubscribe}\n   * from an endpoint.\n   *\n   * The actual {@link IMessage} will be passed as parameter to the callback.\n   */\n  public onUnhandledMessage: messageCallbackType;\n\n  /**\n   * STOMP brokers can be requested to notify when an operation is actually completed.\n   * Prefer using [Client#watchForReceipt]{@link Client#watchForReceipt}. See\n   * [Client#watchForReceipt]{@link Client#watchForReceipt} for examples.\n   *\n   * The actual {@link IFrame} will be passed as parameter to the callback.\n   */\n  public onUnhandledReceipt: frameCallbackType;\n\n  /**\n   * Will be invoked if {@link IFrame} of an unknown type is received from the STOMP broker.\n   *\n   * The actual {@link IFrame} will be passed as parameter to the callback.\n   */\n  public onUnhandledFrame: frameCallbackType;\n\n  /**\n   * `true` if there is an active connection to STOMP Broker\n   */\n  get connected(): boolean {\n    return !!this._stompHandler && this._stompHandler.connected;\n  }\n\n  /**\n   * Callback, invoked on before a connection to the STOMP broker.\n   *\n   * You can change options on the client, which will impact the immediate connecting.\n   * It is valid to call [Client#decativate]{@link Client#deactivate} in this callback.\n   *\n   * As of version 5.1, this callback can be\n   * [async](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)\n   * (i.e., it can return a\n   * [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)).\n   * In that case, connect will be called only after the Promise is resolved.\n   * This can be used to reliably fetch credentials, access token etc. from some other service\n   * in an asynchronous way.\n   */\n  public beforeConnect: () => void | Promise<void>;\n\n  /**\n   * Callback, invoked on every successful connection to the STOMP broker.\n   *\n   * The actual {@link IFrame} will be passed as parameter to the callback.\n   * Sometimes clients will like to use headers from this frame.\n   */\n  public onConnect: frameCallbackType;\n\n  /**\n   * Callback, invoked on every successful disconnection from the STOMP broker. It will not be invoked if\n   * the STOMP broker disconnected due to an error.\n   *\n   * The actual Receipt {@link IFrame} acknowledging the DISCONNECT will be passed as parameter to the callback.\n   *\n   * The way STOMP protocol is designed, the connection may close/terminate without the client\n   * receiving the Receipt {@link IFrame} acknowledging the DISCONNECT.\n   * You might find [Client#onWebSocketClose]{@link Client#onWebSocketClose} more appropriate to watch\n   * STOMP broker disconnects.\n   */\n  public onDisconnect: frameCallbackType;\n\n  /**\n   * Callback, invoked on an ERROR frame received from the STOMP Broker.\n   * A compliant STOMP Broker will close the connection after this type of frame.\n   * Please check broker specific documentation for exact behavior.\n   *\n   * The actual {@link IFrame} will be passed as parameter to the callback.\n   */\n  public onStompError: frameCallbackType;\n\n  /**\n   * Callback, invoked when underlying WebSocket is closed.\n   *\n   * Actual [CloseEvent]{@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   * is passed as parameter to the callback.\n   */\n  public onWebSocketClose: closeEventCallbackType;\n\n  /**\n   * Callback, invoked when underlying WebSocket raises an error.\n   *\n   * Actual [Event]{@link https://developer.mozilla.org/en-US/docs/Web/API/Event}\n   * is passed as parameter to the callback.\n   */\n  public onWebSocketError: wsErrorCallbackType;\n\n  /**\n   * Set it to log the actual raw communication with the broker.\n   * When unset, it logs headers of the parsed frames.\n   *\n   * Changes effect from the next broker reconnect.\n   *\n   * **Caution: this assumes that frames only have valid UTF8 strings.**\n   */\n  public logRawCommunication: boolean;\n\n  /**\n   * By default, debug messages are discarded. To log to `console` following can be used:\n   *\n   * ```javascript\n   *        client.debug = function(str) {\n   *          console.log(str);\n   *        };\n   * ```\n   *\n   * Currently this method does not support levels of log. Be aware that the\n   * output can be quite verbose\n   * and may contain sensitive information (like passwords, tokens etc.).\n   */\n  public debug: debugFnType;\n\n  /**\n   * Browsers do not immediately close WebSockets when `.close` is issued.\n   * This may cause reconnection to take a significantly long time in case\n   *  of some types of failures.\n   * In case of incoming heartbeat failure, this experimental flag instructs\n   * the library to discard the socket immediately\n   * (even before it is actually closed).\n   */\n  public discardWebsocketOnCommFailure: boolean = false;\n\n  /**\n   * version of STOMP protocol negotiated with the server, READONLY\n   */\n  get connectedVersion(): string | undefined {\n    return this._stompHandler ? this._stompHandler.connectedVersion : undefined;\n  }\n\n  private _stompHandler: StompHandler | undefined;\n\n  /**\n   * if the client is active (connected or going to reconnect)\n   */\n  get active(): boolean {\n    return this.state === ActivationState.ACTIVE;\n  }\n\n  /**\n   * It will be called on state change.\n   *\n   * When deactivating, it may go from ACTIVE to INACTIVE without entering DEACTIVATING.\n   */\n  public onChangeState: (state: ActivationState) => void;\n\n  private _changeState(state: ActivationState) {\n    this.state = state;\n    this.onChangeState(state);\n  }\n\n  /**\n   * Activation state.\n   *\n   * It will usually be ACTIVE or INACTIVE.\n   * When deactivating, it may go from ACTIVE to INACTIVE without entering DEACTIVATING.\n   */\n  public state: ActivationState = ActivationState.INACTIVE;\n\n  private _reconnector: any;\n\n  /**\n   * Create an instance.\n   */\n  constructor(conf: StompConfig = {}) {\n    // No op callbacks\n    const noOp = () => {};\n    this.debug = noOp;\n    this.beforeConnect = noOp;\n    this.onConnect = noOp;\n    this.onDisconnect = noOp;\n    this.onUnhandledMessage = noOp;\n    this.onUnhandledReceipt = noOp;\n    this.onUnhandledFrame = noOp;\n    this.onStompError = noOp;\n    this.onWebSocketClose = noOp;\n    this.onWebSocketError = noOp;\n    this.logRawCommunication = false;\n    this.onChangeState = noOp;\n\n    // These parameters would typically get proper values before connect is called\n    this.connectHeaders = {};\n    this._disconnectHeaders = {};\n\n    // Apply configuration\n    this.configure(conf);\n  }\n\n  /**\n   * Update configuration.\n   */\n  public configure(conf: StompConfig): void {\n    // bulk assign all properties to this\n    (Object as any).assign(this, conf);\n  }\n\n  /**\n   * Initiate the connection with the broker.\n   * If the connection breaks, as per [Client#reconnectDelay]{@link Client#reconnectDelay},\n   * it will keep trying to reconnect.\n   *\n   * Call [Client#deactivate]{@link Client#deactivate} to disconnect and stop reconnection attempts.\n   */\n  public activate(): void {\n    const _activate = () => {\n      if (this.active) {\n        this.debug('Already ACTIVE, ignoring request to activate');\n        return;\n      }\n\n      this._changeState(ActivationState.ACTIVE);\n\n      this._connect();\n    };\n\n    // if it is deactivating, wait for it to complete before activating.\n    if (this.state === ActivationState.DEACTIVATING) {\n      this.debug('Waiting for deactivation to finish before activating');\n      this.deactivate().then(() => {\n        _activate();\n      });\n    } else {\n      _activate();\n    }\n  }\n\n  private async _connect(): Promise<void> {\n    await this.beforeConnect();\n\n    if (this._stompHandler) {\n      this.debug('There is already a stompHandler, skipping the call to connect');\n      return;\n    }\n\n    if (!this.active) {\n      this.debug(\n        'Client has been marked inactive, will not attempt to connect'\n      );\n      return;\n    }\n\n    // setup connection watcher\n    if (this.connectionTimeout > 0) {\n      // clear first\n      if (this._connectionWatcher) {\n        clearTimeout(this._connectionWatcher);\n      }\n      this._connectionWatcher = setTimeout(() => {\n        if (this.connected) {\n          return;\n        }\n        // Connection not established, close the underlying socket\n        // a reconnection will be attempted\n        this.debug(\n          `Connection not established in ${this.connectionTimeout}ms, closing socket`\n        );\n        this.forceDisconnect();\n      }, this.connectionTimeout);\n    }\n\n    this.debug('Opening Web Socket...');\n\n    // Get the actual WebSocket (or a similar object)\n    const webSocket = this._createWebSocket();\n\n    this._stompHandler = new StompHandler(this, webSocket, {\n      debug: this.debug,\n      stompVersions: this.stompVersions,\n      connectHeaders: this.connectHeaders,\n      disconnectHeaders: this._disconnectHeaders,\n      heartbeatIncoming: this.heartbeatIncoming,\n      heartbeatOutgoing: this.heartbeatOutgoing,\n      splitLargeFrames: this.splitLargeFrames,\n      maxWebSocketChunkSize: this.maxWebSocketChunkSize,\n      forceBinaryWSFrames: this.forceBinaryWSFrames,\n      logRawCommunication: this.logRawCommunication,\n      appendMissingNULLonIncoming: this.appendMissingNULLonIncoming,\n      discardWebsocketOnCommFailure: this.discardWebsocketOnCommFailure,\n\n      onConnect: frame => {\n        // Successfully connected, stop the connection watcher\n        if (this._connectionWatcher) {\n          clearTimeout(this._connectionWatcher);\n          this._connectionWatcher = undefined;\n        }\n\n        if (!this.active) {\n          this.debug(\n            'STOMP got connected while deactivate was issued, will disconnect now'\n          );\n          this._disposeStompHandler();\n          return;\n        }\n        this.onConnect(frame);\n      },\n      onDisconnect: frame => {\n        this.onDisconnect(frame);\n      },\n      onStompError: frame => {\n        this.onStompError(frame);\n      },\n      onWebSocketClose: evt => {\n        this._stompHandler = undefined; // a new one will be created in case of a reconnect\n\n        if (this.state === ActivationState.DEACTIVATING) {\n          // Mark deactivation complete\n          this._changeState(ActivationState.INACTIVE);\n        }\n\n        // The callback is called before attempting to reconnect, this would allow the client\n        // to be `deactivated` in the callback.\n        this.onWebSocketClose(evt);\n\n        if (this.active) {\n          this._schedule_reconnect();\n        }\n      },\n      onWebSocketError: evt => {\n        this.onWebSocketError(evt);\n      },\n      onUnhandledMessage: message => {\n        this.onUnhandledMessage(message);\n      },\n      onUnhandledReceipt: frame => {\n        this.onUnhandledReceipt(frame);\n      },\n      onUnhandledFrame: frame => {\n        this.onUnhandledFrame(frame);\n      },\n    });\n\n    this._stompHandler.start();\n  }\n\n  private _createWebSocket(): IStompSocket {\n    let webSocket: IStompSocket;\n\n    if (this.webSocketFactory) {\n      webSocket = this.webSocketFactory();\n    } else if (this.brokerURL) {\n      webSocket = new WebSocket(\n        this.brokerURL,\n        this.stompVersions.protocolVersions()\n      );\n    } else {\n      throw new Error('Either brokerURL or webSocketFactory must be provided');\n    }\n    webSocket.binaryType = 'arraybuffer';\n    return webSocket;\n  }\n\n  private _schedule_reconnect(): void {\n    if (this.reconnectDelay > 0) {\n      this.debug(`STOMP: scheduling reconnection in ${this.reconnectDelay}ms`);\n\n      this._reconnector = setTimeout(() => {\n        this._connect();\n      }, this.reconnectDelay);\n    }\n  }\n\n  /**\n   * Disconnect if connected and stop auto reconnect loop.\n   * Appropriate callbacks will be invoked if there is an underlying STOMP connection.\n   *\n   * This call is async. It will resolve immediately if there is no underlying active websocket,\n   * otherwise, it will resolve after the underlying websocket is properly disposed of.\n   *\n   * It is not an error to invoke this method more than once.\n   * Each of those would resolve on completion of deactivation.\n   *\n   * To reactivate, you can call [Client#activate]{@link Client#activate}.\n   *\n   * Experimental: pass `force: true` to immediately discard the underlying connection.\n   * This mode will skip both the STOMP and the Websocket shutdown sequences.\n   * In some cases, browsers take a long time in the Websocket shutdown\n   * if the underlying connection had gone stale.\n   * Using this mode can speed up.\n   * When this mode is used, the actual Websocket may linger for a while\n   * and the broker may not realize that the connection is no longer in use.\n   *\n   * It is possible to invoke this method initially without the `force` option\n   * and subsequently, say after a wait, with the `force` option.\n   */\n  public async deactivate(options: { force?: boolean } = {}): Promise<void> {\n    const force: boolean = options.force || false;\n    const needToDispose = this.active;\n    let retPromise: Promise<void>;\n\n    if (this.state === ActivationState.INACTIVE) {\n      this.debug(`Already INACTIVE, nothing more to do`);\n      return Promise.resolve();\n    }\n\n    this._changeState(ActivationState.DEACTIVATING);\n\n    // Clear if a reconnection was scheduled\n    if (this._reconnector) {\n      clearTimeout(this._reconnector);\n      this._reconnector = undefined;\n    }\n\n    if (\n      this._stompHandler &&\n      // @ts-ignore - if there is a _stompHandler, there is the webSocket\n      this.webSocket.readyState !== StompSocketState.CLOSED\n    ) {\n      const origOnWebSocketClose = this._stompHandler.onWebSocketClose;\n      // we need to wait for the underlying websocket to close\n      retPromise = new Promise<void>((resolve, reject) => {\n        // @ts-ignore - there is a _stompHandler\n        this._stompHandler.onWebSocketClose = evt => {\n          origOnWebSocketClose(evt);\n          resolve();\n        };\n      });\n    } else {\n      // indicate that auto reconnect loop should terminate\n      this._changeState(ActivationState.INACTIVE);\n      return Promise.resolve();\n    }\n\n    if (force) {\n      this._stompHandler?.discardWebsocket();\n    } else if (needToDispose) {\n      this._disposeStompHandler();\n    }\n\n    return retPromise;\n  }\n\n  /**\n   * Force disconnect if there is an active connection by directly closing the underlying WebSocket.\n   * This is different from a normal disconnect where a DISCONNECT sequence is carried out with the broker.\n   * After forcing disconnect, automatic reconnect will be attempted.\n   * To stop further reconnects call [Client#deactivate]{@link Client#deactivate} as well.\n   */\n  public forceDisconnect() {\n    if (this._stompHandler) {\n      this._stompHandler.forceDisconnect();\n    }\n  }\n\n  private _disposeStompHandler() {\n    // Dispose STOMP Handler\n    if (this._stompHandler) {\n      this._stompHandler.dispose();\n    }\n  }\n\n  /**\n   * Send a message to a named destination. Refer to your STOMP broker documentation for types\n   * and naming of destinations.\n   *\n   * STOMP protocol specifies and suggests some headers and also allows broker-specific headers.\n   *\n   * `body` must be String.\n   * You will need to covert the payload to string in case it is not string (e.g. JSON).\n   *\n   * To send a binary message body, use `binaryBody` parameter. It should be a\n   * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n   * Sometimes brokers may not support binary frames out of the box.\n   * Please check your broker documentation.\n   *\n   * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n   * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n   * For binary messages, `content-length` header is always added.\n   *\n   * Caution: The broker will, most likely, report an error and disconnect\n   * if the message body has NULL octet(s) and `content-length` header is missing.\n   *\n   * ```javascript\n   *        client.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n   *\n   *        // Only destination is mandatory parameter\n   *        client.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n   *\n   *        // Skip content-length header in the frame to the broker\n   *        client.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n   *\n   *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n   *        // setting content-type header is not mandatory, however a good practice\n   *        client.publish({destination: '/topic/special', binaryBody: binaryData,\n   *                         headers: {'content-type': 'application/octet-stream'}});\n   * ```\n   */\n  public publish(params: IPublishParams) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.publish(params);\n  }\n\n  private _checkConnection() {\n    if (!this.connected) {\n      throw new TypeError('There is no underlying STOMP connection');\n    }\n  }\n\n  /**\n   * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n   * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n   * The value (say receipt-id) for this header needs to be unique for each use.\n   * Typically, a sequence, a UUID, a random number or a combination may be used.\n   *\n   * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n   * The operation needs to be matched based on the value of the receipt-id.\n   *\n   * This method allows watching for a receipt and invoking the callback\n   *  when the corresponding receipt has been received.\n   *\n   * The actual {@link IFrame} will be passed as parameter to the callback.\n   *\n   * Example:\n   * ```javascript\n   *        // Subscribing with acknowledgement\n   *        let receiptId = randomText();\n   *\n   *        client.watchForReceipt(receiptId, function() {\n   *          // Will be called after server acknowledges\n   *        });\n   *\n   *        client.subscribe(TEST.destination, onMessage, {receipt: receiptId});\n   *\n   *\n   *        // Publishing with acknowledgement\n   *        receiptId = randomText();\n   *\n   *        client.watchForReceipt(receiptId, function() {\n   *          // Will be called after server acknowledges\n   *        });\n   *        client.publish({destination: TEST.destination, headers: {receipt: receiptId}, body: msg});\n   * ```\n   */\n  public watchForReceipt(receiptId: string, callback: frameCallbackType): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.watchForReceipt(receiptId, callback);\n  }\n\n  /**\n   * Subscribe to a STOMP Broker location. The callback will be invoked for each\n   * received message with the {@link IMessage} as argument.\n   *\n   * Note: The library will generate a unique ID if there is none provided in the headers.\n   *       To use your own ID, pass it using the `headers` argument.\n   *\n   * ```javascript\n   *        callback = function(message) {\n   *        // called when the client receives a STOMP message from the server\n   *          if (message.body) {\n   *            alert(\"got message with body \" + message.body)\n   *          } else {\n   *            alert(\"got empty message\");\n   *          }\n   *        });\n   *\n   *        var subscription = client.subscribe(\"/queue/test\", callback);\n   *\n   *        // Explicit subscription id\n   *        var mySubId = 'my-subscription-id-001';\n   *        var subscription = client.subscribe(destination, callback, { id: mySubId });\n   * ```\n   */\n  public subscribe(\n    destination: string,\n    callback: messageCallbackType,\n    headers: StompHeaders = {}\n  ): StompSubscription {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    return this._stompHandler.subscribe(destination, callback, headers);\n  }\n\n  /**\n   * It is preferable to unsubscribe from a subscription by calling\n   * `unsubscribe()` directly on {@link StompSubscription} returned by `client.subscribe()`:\n   *\n   * ```javascript\n   *        var subscription = client.subscribe(destination, onmessage);\n   *        // ...\n   *        subscription.unsubscribe();\n   * ```\n   *\n   * See: https://stomp.github.com/stomp-specification-1.2.html#UNSUBSCRIBE UNSUBSCRIBE Frame\n   */\n  public unsubscribe(id: string, headers: StompHeaders = {}): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.unsubscribe(id, headers);\n  }\n\n  /**\n   * Start a transaction, the returned {@link ITransaction} has methods - [commit]{@link ITransaction#commit}\n   * and [abort]{@link ITransaction#abort}.\n   *\n   * `transactionId` is optional, if not passed the library will generate it internally.\n   */\n  public begin(transactionId?: string): ITransaction {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    return this._stompHandler.begin(transactionId);\n  }\n\n  /**\n   * Commit a transaction.\n   *\n   * It is preferable to commit a transaction by calling [commit]{@link ITransaction#commit} directly on\n   * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\n   *\n   * ```javascript\n   *        var tx = client.begin(txId);\n   *        //...\n   *        tx.commit();\n   * ```\n   */\n  public commit(transactionId: string): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.commit(transactionId);\n  }\n\n  /**\n   * Abort a transaction.\n   * It is preferable to abort a transaction by calling [abort]{@link ITransaction#abort} directly on\n   * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\n   *\n   * ```javascript\n   *        var tx = client.begin(txId);\n   *        //...\n   *        tx.abort();\n   * ```\n   */\n  public abort(transactionId: string): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.abort(transactionId);\n  }\n\n  /**\n   * ACK a message. It is preferable to acknowledge a message by calling [ack]{@link IMessage#ack} directly\n   * on the {@link IMessage} handled by a subscription callback:\n   *\n   * ```javascript\n   *        var callback = function (message) {\n   *          // process the message\n   *          // acknowledge it\n   *          message.ack();\n   *        };\n   *        client.subscribe(destination, callback, {'ack': 'client'});\n   * ```\n   */\n  public ack(\n    messageId: string,\n    subscriptionId: string,\n    headers: StompHeaders = {}\n  ): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.ack(messageId, subscriptionId, headers);\n  }\n\n  /**\n   * NACK a message. It is preferable to acknowledge a message by calling [nack]{@link IMessage#nack} directly\n   * on the {@link IMessage} handled by a subscription callback:\n   *\n   * ```javascript\n   *        var callback = function (message) {\n   *          // process the message\n   *          // an error occurs, nack it\n   *          message.nack();\n   *        };\n   *        client.subscribe(destination, callback, {'ack': 'client'});\n   * ```\n   */\n  public nack(\n    messageId: string,\n    subscriptionId: string,\n    headers: StompHeaders = {}\n  ): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.nack(messageId, subscriptionId, headers);\n  }\n}\n"],"names":["reactPropsRegex","isPropValid","memoize","prop","test","charCodeAt","testOmitPropsOnStringTag","testOmitPropsOnComponent","key","getDefaultShouldForwardProp","tag","composeShouldForwardProps","options","isReal","shouldForwardProp","optionsShouldForwardProp","__emotion_forwardProp","propName","Insertion","_ref","cache","serialized","isStringTag","registerStyles","useInsertionEffectAlwaysWithSyncFallback","insertStyles","newStyled","createStyled","identifierName","targetClassName","__emotion_real","baseTag","__emotion_base","undefined","label","target","defaultShouldForwardProp","shouldUseAs","args","arguments","styles","__emotion_styles","slice","push","raw","apply","process","len","length","i","Styled","withEmotionCache","props","ref","FinalTag","as","className","classInterpolations","mergedProps","theme","React","ThemeContext","getRegisteredStyles","registered","serializeStyles","concat","name","finalShouldForwardProp","newProps","_key","displayName","defaultProps","Object","defineProperty","value","withComponent","nextTag","nextOptions","_extends","bind","forEach","tagName","BYTE","FrameImpl","constructor","params","command","headers","body","binaryBody","escapeHeaderValues","skipContentLengthHeader","this","assign","_binaryBody","isBinaryBody","_body","TextDecoder","decode","TextEncoder","encode","fromRawFrame","rawFrame","trim","str","replace","header","reverse","indexOf","hdrValueUnEscape","toString","serializeCmdAndHeaders","serialize","cmdAndHeaders","toUnit8Array","buffer","lines","keys","hdrValueEscape","isBodyEmpty","bodyLength","join","sizeOfUTF8","s","uint8CmdAndHeaders","nullTerminator","Uint8Array","uint8Frame","set","marshall","Parser","onFrame","onIncomingPing","_encoder","_decoder","_token","_initState","parseChunk","segment","chunk","appendMissingNULLonIncoming","chunkWithNull","byte","_onByte","_collectFrame","_collectCommand","_reinjectByte","_results","_consumeTokenAsUTF8","_collectHeaders","_consumeByte","_collectHeaderKey","_setupCollectBody","_headerKey","_collectHeaderValue","contentLengthHeader","filter","_bodyBytesRemaining","parseInt","_collectBodyFixedSize","_collectBodyNullTerminated","_retrievedBody","_consumeTokenAsRaw","e","console","log","rawResult","StompSocketState","ActivationState","Versions","versions","supportedVersions","protocolVersions","map","x","V1_0","V1_1","V1_2","default","StompHandler","_client","_webSocket","config","_connected","_serverFrameHandlers","CONNECTED","frame","debug","server","_connectedVersion","version","_escapeHeaderValues","_setupHeartbeat","onConnect","MESSAGE","subscription","onReceive","_subscriptions","onUnhandledMessage","message","client","messageId","ack","nack","RECEIPT","callback","_receiptWatchers","onUnhandledReceipt","ERROR","onStompError","_counter","_partialData","_lastServerActivityTS","Date","now","stompVersions","connectHeaders","disconnectHeaders","heartbeatIncoming","heartbeatOutgoing","splitLargeFrames","maxWebSocketChunkSize","forceBinaryWSFrames","logRawCommunication","discardWebsocketOnCommFailure","onDisconnect","onWebSocketClose","onWebSocketError","onUnhandledFrame","connectedVersion","connected","start","parser","onmessage","evt","rawChunkAsString","data","ArrayBuffer","onclose","closeEvent","url","_cleanUp","onerror","errorEvent","onopen","_transmit","serverOutgoing","serverIncoming","split","v","ttl","Math","max","_pinger","setInterval","readyState","OPEN","send","_ponger","delta","_closeOrDiscardWebsocket","discardWebsocket","_closeWebsocket","forceDisconnect","CONNECTING","close","webSocket","terminate","msg","noOp","ts","id","random","substring","origOnClose","delay","getTime","code","reason","call","wasClean","rawChunk","out","dispose","receipt","watchForReceipt","error","clearInterval","publish","destination","hdrs","receiptId","subscribe","unsubscribe","begin","transactionId","txId","transaction","commit","abort","subscriptionId","Client","conf","connectionTimeout","reconnectDelay","state","INACTIVE","beforeConnect","onChangeState","_disconnectHeaders","configure","_this$_stompHandler","_stompHandler","active","ACTIVE","_changeState","activate","_activate","_connect","DEACTIVATING","deactivate","then","_connectionWatcher","clearTimeout","setTimeout","_createWebSocket","_disposeStompHandler","_schedule_reconnect","webSocketFactory","brokerURL","Error","WebSocket","binaryType","_reconnector","force","needToDispose","retPromise","Promise","resolve","CLOSED","origOnWebSocketClose","reject","_this$_stompHandler2","_checkConnection","TypeError"],"sourceRoot":""}